% !TEX root = ../paper.tex
The grammar of SQL is declarative. By design, users can write queries in the way they feel most comfortable, letting well-established equivalence rules dictate a final evaluation strategy.  
As a result, many syntactically distinct queries may still be semantically equivalent.  
Recall example queries 1 and 3, paraphrased here:

{\footnotesize
\begin{enumerate}
\item\begin{verbatim}
SELECT name FROM user 
WHERE rank = 'a' OR rank='s'
\end{verbatim}
\stepcounter{enumi}
\item\begin{verbatim}
SELECT name FROM user WHERE rank = 'a'
UNION SELECT name FROM user WHERE rank = 's'
\end{verbatim}
\end{enumerate}
}

Though semantically distinct, these queries produce identical results for any input.  
Unfortunately similarity of results is not practical to implement: General query equivalence is NP-complete~\cite{Chandra:1977:OIC:800105.803397} for SQL92 and earlier, while SQL99 and later versions of SQL are turing-complete, due to the introduction of recursive queries.  

However, we can still significantly improve clustering quality by standardizing certain SQL features into a more regular form with techniques such as canonicalizing names and aliases, removing syntactic sugaring, and standardizing nested query predicates.
This process of \emph{regularization} aims to produce a new query that is more likely to be \emph{structurally} similar to other \emph{semantically} similar queries. 
Because the output is an ordinary SQL query, regularization may be used with any similarity metric.
These process is similarly used in~\cite{Chandra:2016:PMA:3007263.3007304, sapia1999modeling}, where Chandra~\textit{et al.}~\cite{Chandra:2016:PMA:3007263.3007304} generate mutations of SQL queries to catch diversions from a baseline query, and Sapia~\cite{sapia1999modeling} creates OLAP query prototypes based on selected features and models user profiles.

Although the techniques utilized for regularization are widely used in other settings, this chapter introduces their usage to improve clustering quality.
All the techniques are tested individually to find their impact on the regularization's overall effect.
Experiments in Section~\ref{subsec:evaluation} show consistent improvements for all metrics evaluated in practical real world settings.
In this section, the transformations that we apply to regularize queries and the conditions under which they may be applied are described.  

\subsection{Regularization Rules}
\label{sec:regularizationrules}

\tinysection{Canonicalize Names and Aliases}
As we will show in our experiments in Section~\ref{sec:experiment}, table and attribute aliases are a significant source of error in matching. Consider the following two queries:

{\footnotesize
\begin{enumerate}
\addtocounter{enumi}{4}
\item\begin{verbatim}
SELECT name FROM user
\end{verbatim}
\item\begin{verbatim}
SELECT id 
FROM (SELECT name AS id FROM user) AS t
\end{verbatim}
\end{enumerate}
}

Although these queries are functionally identical, variable names are aliased in different ways.  
This is especially damaging for the three structural heuristics that we evaluate, each of which assumes that variable names follow a globally consistent pattern.  
Our first regularization step attempts to create a canonical naming scheme for both attributes and tables which is similar to one used in \cite{Chandra:2016:PMA:3007263.3007304}.

\begin{table}
\centering
\begin{tabular}{C{2.5cm}| C{5cm}}
\textbf{Before}  & \textbf{After} \\
\hline
$b\; \{>, \geq\}\; a$ & $a\; \{<, \leq\}\; b$\\
{\footnotesize x \textbf{BETWEEN} (a,b)}   & $a\leq x$ \textbf{AND} $x\leq b$\\
 x \textbf{IN} ($a$,$b$,\ldots) &  x=$a$ \textbf{OR} x=$b$ \textbf{OR} \ldots\\
 isnull(x,y)  &\textbf{CASE WHEN} x is null \textbf{THEN} y \textbf{END}          \\
\end{tabular}
\caption{Syntactic Desugaring}
\label{table:syntacticsugar}
\vspace*{-5mm}
\end{table}

\tinysection{Syntax Desugaring}
We remove SQL's redundant syntactic sugar following basic pattern-replacements as shown in Table~\ref{table:syntacticsugar}.  

\tinysection{EXISTS Standardization}
Although SQL admits four classes of nested query predicates: (\texttt{EXISTS}, \texttt{IN}, \texttt{ANY}, and \texttt{ALL}), the \texttt{EXISTS} predicate is general enough to capture the semantics of the remaining operators~\cite{Chandra:2016:PMA:3007263.3007304}.  
Queries using the others are rewritten:\\
\noindent \texttt{x IN (SELECT y \ldots)} \textbf{becomes} \\\hspace*{22.5mm}\texttt{EXISTS (SELECT * \ldots WHERE x = y)}\\
\noindent \texttt{x $<$ ANY (SELECT y \ldots)} \textbf{becomes}  \\\hspace*{22.5mm}\texttt{EXISTS (SELECT * \ldots WHERE x $<$ y)}\\
\noindent \texttt{x $<$ ALL (SELECT y \ldots)} \textbf{becomes}  \\\hspace*{14.5mm}\texttt{NOT EXISTS (SELECT * \ldots WHERE x $\geq$ y)}

\tinysection{DNF Normalization}
All boolean-valued expressions are normalized by converting them to disjunctive normal form (DNF).  
The choice of DNF is motivated by the ubiquity of conjunctive queries in most database applications, as well as by the natural correspondence between disjunctions and unions that we exploit below.

\tinysection{Commutative Operator Ordering}
The order of expressions involving commutative and associative operators (e.g., $\wedge$, $\vee$, $+$, and $\times$) are standardized by defining a canonical order of all operands and traversing the expression tree bottom-up to ensure consistent order of all operands.

%\smallskip

\tinysection{Flatten FROM-Nesting}
Nested sub-queries are merged in a \texttt{FROM} clause with its parent query as described in \cite{Chandra:2016:PMA:3007263.3007304}.

\tinysection{Nested Query De-correlation}
A common database optimization called nested-query de-correlation~\cite{492194} converts some \texttt{EXISTS} predicates into joins for more efficient evaluation. 
Note that this rewrite does not guarantee query result equivalence under \textit{bag semantics} due to duplicated rows in the result.
Hence we require that the parent query is either a \texttt{SELECT DISTINCT} or a duplicate-insensitive aggregate~\cite{ilprints101} (e.g. $max\{1,1\}=max\{1\}$, but $sum\{1,1\}\neq sum\{1\}$).
If the \texttt{EXISTS} predicate is in a purely conjunctive \texttt{WHERE} clause, the de-correlation process simply moves the query nested in the \texttt{EXISTS} into the \texttt{FROM} clause of its parent query. 
The (formerly) nested query's \texttt{WHERE} clause can be then merged into the parent's \texttt{WHERE} clause. 
Specifically, if the input query is of the form:

{\footnotesize
\begin{verbatim}
SELECT ... FROM R WHERE 
           EXISTS (SELECT ... FROM S WHERE q)
\end{verbatim}
}

then the output query will have the form:

{\footnotesize
\begin{verbatim}
SELECT ... FROM R, (SELECT ... FROM S) WHERE q
\end{verbatim}
}

To de-correlate a \texttt{NOT EXISTS} predicate, we use the set-difference operator \texttt{EXCEPT}.  
If the input is of the form:
{\footnotesize
\begin{verbatim}
SELECT DISTINCT... FROM R WHERE 
       NOT EXISTS (SELECT ... FROM S WHERE q)
\end{verbatim}
}
then the output will be of the form
{\footnotesize
\begin{verbatim}
(SELECT DISTINCT... FROM R) EXCEPT 
  (SELECT DISTINCT... FROM R, WHERE 
           EXISTS (SELECT ... FROM S WHERE q))
\end{verbatim}
}

\tinysection{OR-UNION Transform}
A regularization transformation is used that exploits the relationship between OR and UNION. 
This rewrite does not guarantee query result equivalence, also due to potentially duplicated rows in query result.
Recall the equivalence between logical OR and UNION mentioned in our first example. 
Naively, we might convert the DNF-form predicates into UNION queries:\\
\noindent\texttt{SELECT }\ldots\texttt{ WHERE q OR p OR }\ldots\texttt{} \textbf{becomes}\\
\hspace*{5mm}\texttt{SELECT }\ldots\texttt{ WHERE q UNION SELECT }\ldots\texttt{ WHERE p UNION }\ldots\\
However, duplicates caused by the possible correlation between clauses in DNF will break the equivalence of this rewrite. Consider the following query:
{\footnotesize
\begin{verbatim}
	SELECT Score FROM Exam WHERE Score>60 OR Pass=1
\end{verbatim}
}
Students who pass the exam overlap with those whose score greater than 60.
Thus the rewritten query would not be exactly equivalent, as it may include duplicate rows.
As a result, we require the query to satisfy the same condition mentioned in previous rule \textit{nested query de-correlation}.

\tinysection{Union Pull-Out} Since the prior transformation may introduce UNION operator in nested subqueries, we push selection predicates down into the union as well.